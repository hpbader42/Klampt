# Reading Python documentation

This document describes a bit more about how to interpret the [Klampt Python API documentation](http://klampt.org/pyklampt_docs).  Some of the modules, like [vectorops](../Python/klampt/math/vectorops.py), [ik](../Python/klampt/model/ik.py), and [loader](../Python/klampt/io/loader.py), are written in native Python, and so their documentation is extracted nicely.  However, for speed and interoperability, the core functionality for modeling and simulating robots is implemented as a thin wrapper around the C++ API. 

These bindings are generated by the SWIG tool, and hence the documentation of many important classes looks a little weird due to the SWIG generation process.  This is can be especially confusing if you are not familiar with C++, since the auto-generated docstrings include some C++ notation.  

Note that these core objects are in the ```robotsim```, ```motionplanning```, and the lesser-used ```rootfind`` modules.  Many important classes in ```robotsim``` module, like [WorldModel](http://klampt.org/pyklampt_docs/classklampt_1_1robotsim_1_1WorldModel.html), [RobotModel](http://klampt.org/pyklampt_docs/classklampt_1_1robotsim_1_1RobotModel.html), [Geometry3D](http://klampt.org/pyklampt_docs/classklampt_1_1robotsim_1_1Geometry3D.html), and [IKObjective](http://klampt.org/pyklampt_docs/classklampt_1_1robotsim_1_1IKObjective.html), get loaded automatically into the klampt namespace upon “import klampt” because they are used so ubiquitously.  It is usually easiest to get a sense of how to use these classes through examples, but you will occasionally find yourself having to wade through the documentation. 

This document will provide a little help interpreting these docstrings.  You can also browse the Klamp't Manual, which documents the core classes of Klamp't in a more sane way.

## Interpreting SWIG-generated docstrings

Let's start to look into how to parse [the documentation for WorldModel](http://klampt.org/pyklampt_docs/classklampt_1_1robotsim_1_1WorldModel.html).  First, a list of methods is provided at the top, but they all have the incredibly unhelpful prototype ```METHOD_NAME(self,args)```.  So instead we need to look at the function documentation.

Let's look first at a simple function, loadElement.  The documentation gives some more detail on the method prototype, and it reads:

```
loadElement(WorldModel self, char const * fn) -> int

Loads some element from a file, automatically detecting its type.
Meshes are interpreted as terrains. The ID is returned, or -1 if
loading failed. 
```

To interpret this, the function takes in two arguments, ```self``` and ```fn```, and returns an integer as output.  ```self``` is obviously the WorldModel instance on which loadElement is invoked.  The ```fn``` object needs to be convertable to type ```char const *```, which in C is a string.  So, ``fn``` should be a Python str object.  

Ultimately, you should interpret this code as providing a method that is called as follows:

```
w = WorldModel()
res = w.loadElement("data/objects/cube.obj")   #the str gets converted to a char const* automatically by SWIG
#res is an int
if res == -1:
    print "Loading cube failed"
else:
    print "Cube loaded, its ID is",res
```

## Overloaded functions

Somewhat more complex are overloaded functions, which can execute different pieces of code depending on the number and type of arguments provided.  Let's look at the __init__ function documentation.  It reads:

```
__init__(WorldModel self) -> WorldModel
__init__(WorldModel self, void * ptrRobotWorld) -> WorldModel
__init__(WorldModel self, WorldModel w) -> WorldModel
```

Which means that there are three overloads, each of which takes self as the first argument (obviously) and either 0 or 1 argument, and produce a WorldModel instance.  The first is what is executed when the Python code ```WorldModel()``` is called. The second or third are executed when ```WorldModel(arg)``` is called, depending on what type arg is.  You probably only need to care about the third overload, which is when you pass another WorldModel instance into the constructor.  It isn't spelled out explicitly, but this is a copy constructor.

Something that is quite annoying is that SWIG does not separately document all overloads of a single function, even when the C++ functions have their own documentation.  We will look into fixing this at some point, but for now you will have to use the manual inspection method below.


## Interpreting source C++ header files

If you are familiar at all with Java or C++, it is often times easier just to browse the C++ header files in [Klampt/Python/klampt/src](../Python/klampt/src).  This is especially so for overloaded functions which do different things depending on their arguments.  Look at the docs for the add method for WorldModel, for instance:

```
add(WorldModel self, char const * name, RobotModel robot) -> RobotModel
add(WorldModel self, char const * name, RigidObjectModel obj) -> RigidObjectModel
add(WorldModel self, char const * name, TerrainModel terrain) -> TerrainModel

Adds a copy of the given terrain to this world, either from this
WorldModel or another. 
```

Hmm... the docstring references terrains, which are only relevant for the *last* overload of this function.  To get better information, let's find WorldModel in the C++ header files.  The key header files are [robotmodel.h](../Python/klampt/src/robotmodel.h), [robotsim.h](../Python/klampt/src/robotsim.h), [robotik.h](../Python/klampt/src/robotik.h), [geometry.h](../Python/klampt/src/geometry.h), and [appearance.h](../Python/klampt/src/appearance.h).  In this case, we find WorldModel in robotmodel.h.  The documentation for these C++ functions are a bit more sane to read:

```
  ///Adds a copy of the given robot to this world, either from this WorldModel
  ///or another.
  RobotModel add(const char* name,const RobotModel& robot);
  ///Adds a copy of the given rigid object to this world, either from this
  ///WorldModel or another.
  RigidObjectModel add(const char* name,const RigidObjectModel& obj);
  ///Adds a copy of the given terrain to this world, either from this
  ///WorldModel or another.
  TerrainModel add(const char* name,const TerrainModel& terrain);
```

where the documentation for a function is listed above it.  (To interpret these function prototypes, we will need to parse out the const's, the \*'s, and the \&'s, which have meaning in C but not so much in Python.  You can see that the SWIG docs have already processed these out.)


